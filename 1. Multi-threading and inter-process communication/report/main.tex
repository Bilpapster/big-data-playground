\documentclass[acmlarge]{acmart}


\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
  \settopmatter{printacmref=false}

\renewcommand{\descriptionlabel}[1]{\hspace{\labelsep}\textit{#1}}
\usepackage{xcolor}
\newcommand{\todo}{{\color{red}\textbf{TODO} }}
\newcommand{\disease}{{\small \texttt{DISEASE}} }
\newcommand{\hospital}{{\small \texttt{HOSPITAL}} }

% christos 1, 4
% vasilis 2, 3

\begin{document}

\title{Multi-Threading Programming and Inter-Process Communication}
\subtitle{M.Sc. course on ``Technologies for Big Data Analysis'' - Assignment 1}

\author{Christos Balaktsis (1234)}
\email{balaktsis@csd.auth.gr}
\author{Vasileios Papastergios (1234)}
\email{papster@csd.auth.gr}
\affiliation{
  \institution{Aristotle University}
  \city{Thessaloniki}
  \country{Greece}
}

\renewcommand{\shortauthors}{C. Balaktsis and V. Papastergios}
\maketitle

\section{Introduction}

The current document is a technical report for the first programming assignment in the M.Sc. course on \emph{Technologies for Big Data Analysis}, offered by the \emph{DWS M.Sc Program}\footnote{https://dws.csd.auth.gr/} of the Aristotle University of Thessaloniki, Greece. The course is taught by Professor Apostolos Papadopoulos~\footnote{https://datalab-old.csd.auth.gr/$\sim$apostol/}. The authors attended the course during their first year of Ph.D. studies at the Institution.

The assignment contains 4 sub-problems and is part of a series, comprising 3 programming assignments on the following topics:
\begin{description}
  \item[Assignment 1] Multi-threading Programming and Inter-Process Communication
  \item[Assignment 2] The Map-Reduce Programming Paradigm
  \item[Assignment 3] Big Data Analytics with Scala and Apache Spark
\end{description}
In this document we focus on Assignment 1 and its 4 sub-problems. We refer to them as \emph{problems} in the rest of the document for simplicity. The source code of our solution has been made available at \texttt{\small https://github.com/ Bilpapster/big-data-playground}.

\textbf{Roadmap}.
The rest of our work is structured as follows. We devote one section for each one of the 4 problems. That means problems 1, 2, 3 and 4 are presented in sections \ref{section:problem1}, \ref{section:problem2}, \ref{section:problem3} and \ref{section:problem4} respectively. For each problem, we first provide the problem statement, as given by the assignment. Next, we thoroughly present the reasoning and/or methodology we have adopted to approach the problem and devise a solution. Wherever applicable, we also provide insights about the source code implementation we have developed. For problems 2 and 4, we complete the respective sections with a discussion about alternatives or improvements the solution could accept, in order to successfully support more complex requirements. Finally, we conclude our work in section \ref{section:conclusion}.

\section{Problem 1: Concurrent Array-Vector Multiplication}
\label{section:problem1}
We discuss here the first problem of the assignment. The main target of the assignment is using multi-threading programming in Java programming language to concurrently perform an algebraic operation.
\subsection{Problem Statement}
It is known that in Linear Algebra we can multiply a matrix with a vector from the right-hand side, provided that the number of columns in the matrix equals the number of rows in the vector. For instance, given a matrix $\mathbf{A}$ with dimensions $n~\times~m$ and a vector $v$ with dimensions $m~\times~1$, then the product $\mathbf{A}*\mathbf{v}$ is an $n~\times~1$ vector, which results from the implementation of the well-known method of multiplying a matrix with a vector. An example is given following: \todo

Provided that we are capable of using $k$ threads, where $k$ is a power of 2 and the matrix has dimensions $n~\times~m$, where $n$ is also a power of 2 and $n>k$, design a solution that computes the product $\mathbf{A}*\mathbf{v}$ using $k$ threads with the most efficient way. Your solution has to initialize both the matrix $\mathbf{A}$ and the vector $\mathbf{v}$ with random numbers in the range $[0, 10]$.

\section{Problem 2: Race against a pandemic}
\label{section:problem2}
The second problem asks for leveraging multi-threading programming in Java programming language, in order to simulate a pandemic spread.
\subsection{Problem Statement}
In this problem, you have to simulate a (simplified) pandemic spread, taking into account new infections, hospitalizations and recoveries occurring concurrently. In particular, suppose that a thread named \disease produces periodically (e.g., every 1 second) a random number of new infected people in the range $(0, k]$ that are in need of hospitalization in ICU\footnote{ICU: Intensive Care Unit}. The Health Care System has a limited number of ICU beds, let $e$ (e.g., 20). At the same time, a thread named \hospital periodically (e.g., every 5 seconds) treats a random number of infected patients in the range $(0, h]$, where $h<k$. When a patient is treated the ICU bed used for their treatment is no longer occupied; thus available for use by another patient.

Develop a solution that simulates the above behavior. Your solution should also keep track of the total number of treated patients, as well as the ones that were not able to find a spot in ICU. The simulation must complete its execution after a predefined number of steps (or time period), which will be given as program argument, alongside with all aforementioned parameters (periods, $k$, $h$, $e$). You should test your solution against different values of the parameters, in order to verify that it correctly operates in all possible cases. How would you convert your solution if, instead of a single hospital, there were three of them, with a single, shared queue of patients?

\section{Problem 3: Key-value server store}
\label{section:problem3}
This is the section for the third problem.
\subsection{Problem Statement}

\section{Problem 4: Multi-server producer-consumer interaction}
\label{section:problem4}
This is the section for the fourth problem.
\subsection{Problem Statement}

\section{Conclusion}
\label{section:conclusion}
This is the section for the conclusion.


\end{document}
\endinput
%%
%% End of file `sample-acmlarge.tex'.
